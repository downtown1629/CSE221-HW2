

# Bi-Modal Skip List: 프로젝트 종합 보고서

## 1. Bi-Modal Skip List의 아이디어 정리

### 1.1 배경 및 문제 정의
현대의 텍스트 편집기 및 IDE 환경은 뚜렷하게 구분되는 두 가지 워크로드(Workload) 단계를 가집니다.
* **작성 단계 (Write-Heavy Phase):** 사용자가 코드를 타이핑하는 단계로, 커서 주변에서 국소적인 삽입과 삭제가 빈번하게 발생합니다.
* **분석 단계 (Read-Heavy Phase):** 컴파일러나 린터(Linter)가 전체 코드를 스캔하거나, 검색 기능을 수행하는 단계로 빠른 순차 접근 및 임의 접근이 요구됩니다.

기존 자료구조들은 이 두 가지 요구사항 중 하나만을 만족시키는 경향이 있습니다.
* `std::vector`: 연속된 메모리로 읽기는 빠르지만, 중간 삽입 시 데이터 이동 비용($O(N)$)이 발생합니다.
* **Gap Buffer:** 편집은 빠르지만, 대용량 파일에서의 임의 접근(Random Access)이나 전체 검색이 비효율적입니다.
* **Linked List:** 삽입은 빠르나, 메모리 파편화로 인해 캐시 효율이 낮고 탐색 비용이 높습니다.

### 1.2 핵심 제안: 상태 적응형 자료구조 (Adaptive Data Structure)
**Bi-Modal Skip List**는 시스템의 상태에 따라 노드의 내부 메모리 레이아웃을 동적으로 **변환(Transmute)**하는 하이브리드 자료구조입니다.
* **Write Mode:** 편집이 일어나는 활성 노드는 **Gap Buffer** 형태로 유지하여 $O(1)$ 삽입 성능을 보장합니다.
* **Read Mode:** 편집이 종료되거나 분석이 필요한 시점에, 노드를 **Compact Array** 형태로 압축하여 메모리 낭비를 줄이고 CPU 캐시 히트율을 극대화합니다.

---

## 2. Bi-Modal Skip List의 형태와 구조

### 2.1 노드의 이원화 (Bi-Modal Nodes)
각 노드는 `std::variant`를 사용하여 런타임에 두 가지 상태 중 하나를 가집니다. 

1.  **Gap Node (쓰기 최적화)**
    * 내부에 '빈 공간(Gap)'을 포함하는 버퍼 구조입니다.
    * 커서 이동 시 데이터 복사 없이 Gap의 위치만 논리적으로 변경하며, 삽입 시 Gap을 채워 넣는 방식으로 동작합니다.
    * 물리적 인덱스와 논리적 인덱스의 매핑 변환을 수행합니다.

2.  **Compact Node (읽기 최적화)**
    * Gap이 제거된 순수한 연속 배열(`std::vector` 형태)입니다.
    * 데이터가 물리적으로 인접해 있어 SIMD 연산이나 CPU 프리패치(Prefetch)에 유리합니다.

### 2.2 인덱스 기반 Skip List (Index-Based Skip List)
개별 노드들은 Skip List 구조로 연결됩니다. 일반적인 Skip List가 '값'을 기준으로 정렬하는 것과 달리, 본 구조는 **'문자열의 길이(Span)'**를 기준으로 인덱싱합니다. 
* **Level & Next Pointers:** 각 노드는 확률적으로 결정된 높이(Level)를 가지며, 레벨별로 다음 노드를 가리키는 포인터를 가집니다.
* **Span (Distance):** 각 링크는 다음 노드까지 도달하기 위해 건너뛰어야 하는 문자의 개수를 저장합니다. 이를 통해 전체 텍스트의 $N$번째 문자에 접근하는 연산을 $O(\log N)$ 시간 복잡도로 수행합니다.

---

## 3. 구현 방법 및 과정

구현은 복잡도를 제어하기 위해 단계적으로 진행되었으며, `AddressSanitizer`를 통한 엄격한 메모리 검증이 수행되었습니다.

### 3.1 핵심 연산 구현
1.  **위치 탐색 (`find_node`):**
    * Skip List의 상위 레벨부터 `span`을 누적하며 목표 인덱스(`pos`)에 근접한 노드를 찾습니다.
    * **경계 보정 (Normalization):** 탐색된 오프셋이 노드의 크기와 일치하거나 넘어설 경우, 안전하게 다음 노드로 넘겨주는 보정 로직을 추가하여 경계값 오류(Boundary Condition Error)를 방지했습니다.

2.  **삽입 (`insert`):**
    * **Expansion:** 대상 노드가 `CompactNode`라면 즉시 `GapNode`로 확장 변환합니다.
    * **Insertion:** Gap Buffer 로직을 통해 문자를 삽입합니다.
    * **Span Update:** 삽입된 문자 수만큼, 해당 노드를 가리키거나 건너뛰는 이전 노드들의 `span` 값을 갱신하여 인덱스 무결성을 유지합니다.
    * **Node Split:** 노드가 설정된 임계값(`NODE_MAX_SIZE`, 예: 4096)을 초과하면 두 개의 노드로 분할하여 밸런스를 유지합니다. 이때 상위 레벨의 연결과 `span` 정보를 수학적으로 재계산하여 토폴로지를 복구합니다.

3.  **최적화 (`optimize` / `to_string`):**
    * 전체 노드를 순회하며 `GapNode`를 `CompactNode`로 변환하여 읽기 모드로 전환합니다.
    * `std::copy` 등을 활용하여 컴파일러가 `memmove`/`memcpy` 등의 SIMD 최적화를 수행할 수 있도록 유도했습니다.

4.  **읽기 최적화 (Internal Iterator):**
    * 기존 외부 반복자(`Iterator`)의 오버헤드(노드 경계 검사, `std::visit` 분기)를 제거하기 위해, **내부 반복자 패턴(`scan` 메서드)**을 도입했습니다.
    * 람다 함수를 인자로 받아 노드 내부 루프를 직접 수행함으로써 함수 호출 비용을 제거하고 자동 벡터화(Auto-Vectorization) 성능을 극대화했습니다.

### 3.2 디버깅 및 트러블슈팅
* **Heap-Buffer-Overflow 해결:** `split_node` 수행 후 토폴로지 갱신 누락으로 인해, 이전 노드가 쪼개진 노드의 범위를 넘어 접근하는 문제를 `AddressSanitizer`로 발견하고, `span` 갱신 로직과 `find_node`의 경계 처리를 수정하여 해결했습니다.
* **Use-After-Move 해결:** 버퍼 확장 시 `std::move` 이후 사이즈를 참조하여 발생한 언더플로우 버그를 수정했습니다.

---

## 4. 벤치마크 과정

자료구조의 성능을 객관적으로 입증하기 위해 세 가지 시나리오를 설계하여 `std::vector`, `std::list`와 비교했습니다.

### 시나리오 A: 순차 편집 (Sequential Editing)
* **설정:** 대용량 텍스트의 중간 지점에 연속적으로 문자를 삽입합니다. (Typing 시뮬레이션)
* **목적:** 데이터 이동 비용($O(N)$)이 발생하는 벡터와 비교하여 Gap Buffer의 효율성을 검증합니다.

### 시나리오 B: 랜덤 액세스 편집 (Random Access Editing) - **핵심 시나리오**
* **설정:** 텍스트의 임의의 위치(Random Index)로 이동하여 문자를 삽입합니다.
* **목적:** 인덱싱 기능이 없는 리스트($O(N)$ 탐색)와 비교하여, Skip List 기반 인덱싱($O(\log N)$)의 우위를 증명합니다.

### 시나리오 C: 읽기 성능 (Read Performance)
* **설정:** 전체 텍스트를 처음부터 끝까지 순회합니다.
* **목적:** 메모리가 불연속적인 노드 구조임에도 불구하고, 내부 반복자 최적화를 통해 얼마나 벡터에 근접한 성능을 낼 수 있는지 측정합니다.

---

## 5. 결과 정리

벤치마크 결과, **Bi-Modal Skip List**는 설계 의도대로 편집과 읽기 성능의 이상적인 균형을 달성했습니다.

### 5.1 삽입 성능 (압도적 우위)
* **순차 삽입:** `std::vector` 대비 **약 60배 이상** 빠른 성능을 기록했습니다. 이는 데이터 이동 비용을 제거했기 때문입니다.
* **랜덤 삽입:** `std::list` 대비 **약 270배** 빠른 성능을 기록했습니다. `std::list`는 삽입 위치를 찾기 위해 $O(N)$ 선형 탐색을 해야 하지만, Bi-Modal Skip List는 $O(\log N)$으로 위치를 찾아내고 $O(1)$로 삽입하기 때문입니다. 이는 본 자료구조의 가장 큰 강점입니다.

### 5.2 읽기 성능 (합리적 트레이드오프)
* 초기 구현에서는 `std::visit` 오버헤드로 인해 느렸으나, **내부 반복자(`scan`) 최적화** 적용 후 초기 대비 **5~6배의 성능 향상**을 이루었습니다.
* 물리적으로 메모리가 연속된 `std::vector`의 Native Speed에는 미치지 못하지만(구조적 한계), `std::list`보다는 빠르거나 대등한 수준을 유지하며 **Linked List 구조의 한계를 극복**했습니다.

### 5.3 결론
본 프로젝트를 통해 구현된 **Bi-Modal Skip List**는 단순한 자료구조의 결합을 넘어, 워크로드의 특성에 맞춰 스스로 최적화하는 **지능형 자료구조**입니다.
* **안전성:** `AddressSanitizer`를 통과한 무결성 확보.
* **고성능:** 랜덤 액세스 편집에서 기존 STL 컨테이너를 압도하는 성능.
* **최적화:** Modern C++ 기법과 로우레벨 최적화를 통한 읽기 속도 극대화.

이 결과는 실제 상용 텍스트 에디터나 로그 시스템 등 고성능이 요구되는 소프트웨어에 즉시 적용 가능한 수준의 성과임을 시사합니다.