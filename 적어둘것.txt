초기 구현에서는 next와 span 배열을 각각 개별적으로 동적 할당했으나, 이는 노드 생성 시 잦은 malloc 호출 오버헤드와 메모리 파편화를 유발하여 랜덤 삽입 성능을 저하시켰다.

이를 해결하기 위해 Single Block Allocation 기법을 도입했다. next와 span을 하나의 연속된 메모리 블록으로 할당하고 포인터 연산을 통해 구획을 나누어 사용함으로써, **메모리 할당 횟수를 50% 감소(2회→1회)**시키고 **공간 지역성(Spatial Locality)**을 극대화했다. 그 결과 std::vector 대비 힙 관리 오버헤드를 획기적으로 줄였다."

보고서 작성 가이드 (Design Section)
Node Merge Strategy: Lazy vs Eager

"본 프로젝트에서는 노드 삭제 시 즉시 병합(Eager Merge)을 수행하는 대신, optimize() 단계에서 일괄 병합(Lazy Merge)하는 전략을 채택했다.

편집 성능 보장: 텍스트 편집기에서 사용자가 백스페이스를 연타할 때마다 메모리 재할당과 병합 연산을 수행하는 것은 불필요한 레이턴시를 유발한다.

구현 복잡도 관리: Skip List의 다층 포인터를 실시간으로 병합하는 것은 오류 가능성이 높다. 대신 Bi-Modal 구조의 이점을 살려, 읽기 모드 전환(optimize) 시점에 안전하게 파편화(Fragmentation)를 해소한다.

결과: 이를 통해 쓰기 작업의 처리량(Throughput)을 유지하면서도, 분석 단계에서는 병합된 Compact Node를 통해 최적의 읽기 성능을 달성했다."